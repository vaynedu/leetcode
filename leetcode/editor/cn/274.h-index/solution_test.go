package leetcode

// 274.H æŒ‡æ•°

import (
	"testing"
)

/**
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ citations ï¼Œå…¶ä¸­ citations[i] è¡¨ç¤ºç ”ç©¶è€…çš„ç¬¬ i ç¯‡è®ºæ–‡è¢«å¼•ç”¨çš„æ¬¡æ•°ã€‚è®¡ç®—å¹¶è¿”å›è¯¥ç ”ç©¶è€…çš„ h æŒ‡æ•°ã€‚

 æ ¹æ®ç»´åŸºç™¾ç§‘ä¸Š h æŒ‡æ•°çš„å®šä¹‰ï¼šh ä»£è¡¨â€œé«˜å¼•ç”¨æ¬¡æ•°â€ ï¼Œä¸€åç§‘ç ”äººå‘˜çš„ h æŒ‡æ•° æ˜¯æŒ‡ä»–ï¼ˆå¥¹ï¼‰è‡³å°‘å‘è¡¨äº† h ç¯‡è®ºæ–‡ï¼Œå¹¶ä¸” è‡³å°‘ æœ‰ h ç¯‡è®ºæ–‡è¢«å¼•ç”¨æ¬¡æ•°å¤§
äºç­‰äº h ã€‚å¦‚æœ h æœ‰å¤šç§å¯èƒ½çš„å€¼ï¼Œh æŒ‡æ•° æ˜¯å…¶ä¸­æœ€å¤§çš„é‚£ä¸ªã€‚



 ç¤ºä¾‹ 1ï¼š


è¾“å…¥ï¼šcitations = [3,0,6,1,5]
è¾“å‡ºï¼š3
è§£é‡Šï¼šç»™å®šæ•°ç»„è¡¨ç¤ºç ”ç©¶è€…æ€»å…±æœ‰ 5 ç¯‡è®ºæ–‡ï¼Œæ¯ç¯‡è®ºæ–‡ç›¸åº”çš„è¢«å¼•ç”¨äº† 3, 0, 6, 1, 5 æ¬¡ã€‚
Â     ç”±äºç ”ç©¶è€…æœ‰ 3 ç¯‡è®ºæ–‡æ¯ç¯‡ è‡³å°‘ è¢«å¼•ç”¨äº† 3 æ¬¡ï¼Œå…¶ä½™ä¸¤ç¯‡è®ºæ–‡æ¯ç¯‡è¢«å¼•ç”¨ ä¸å¤šäº 3 æ¬¡ï¼Œæ‰€ä»¥å¥¹çš„ h æŒ‡æ•°æ˜¯ 3ã€‚

 ç¤ºä¾‹ 2ï¼š


è¾“å…¥ï¼šcitations = [1,3,1]
è¾“å‡ºï¼š1




 æç¤ºï¼š


 n == citations.length
 1 <= n <= 5000
 0 <= citations[i] <= 1000


 Related Topics æ•°ç»„ è®¡æ•°æ’åº æ’åº ğŸ‘ 612 ğŸ‘ 0

*/

// leetcode submit region begin(Prohibit modification and deletion)
func hIndex(citations []int) int {
	n := len(citations)
	// åˆ›å»ºæ¡¶æ•°ç»„ï¼Œç´¢å¼•è¡¨ç¤ºå¼•ç”¨æ¬¡æ•°ï¼Œå€¼è¡¨ç¤ºè¯¥å¼•ç”¨æ¬¡æ•°çš„è®ºæ–‡æ•°é‡
	// ç”±äºå¼•ç”¨æ¬¡æ•°æœ€å¤§ä¸º1000ï¼Œä¸”æœ€å¤šæœ‰nç¯‡è®ºæ–‡ï¼Œæ‰€ä»¥æ¡¶å¤§å°ä¸ºn+1å³å¯
	buckets := make([]int, n+1)

	// ç»Ÿè®¡æ¯ä¸ªå¼•ç”¨æ¬¡æ•°çš„è®ºæ–‡æ•°é‡
	for i := 0; i < n; i++ {
		if citations[i] >= n {
			// å¼•ç”¨æ¬¡æ•°è¶…è¿‡nçš„éƒ½æ”¾åœ¨buckets[n]ä¸­
			buckets[n]++
		} else {
			buckets[citations[i]]++
		}
	}
	// ä»åå¾€å‰ç´¯åŠ ï¼Œè®¡ç®—å¼•ç”¨æ¬¡æ•°å¤§äºç­‰äºiçš„è®ºæ–‡æ€»æ•°
	count := 0
	for i := n; i >= 0; i-- {
		// å¦‚æœå¼•ç”¨æ¬¡æ•°å¤§äºç­‰äºiçš„è®ºæ–‡æ•°é‡ä¸å°‘äºiç¯‡ï¼Œåˆ™hæŒ‡æ•°ä¸ºi
		count += buckets[i]
		if count >= i {
			return i
		}
	}

	return 0

}

//leetcode submit region end(Prohibit modification and deletion)

// æµ‹è¯•å‡½æ•°å®ç°
func TestHIndex(t *testing.T) {
	tests := []struct {
		citations []int
		expected  int
	}{
		{[]int{3, 0, 6, 1, 5}, 3},
		{[]int{1, 3, 1}, 1},
		{[]int{0}, 0},
		{[]int{1}, 1},
		{[]int{100}, 1},
		{[]int{0, 0, 0}, 0},
		{[]int{1, 1, 1, 1}, 1},
	}

	for i, test := range tests {
		result := hIndex(test.citations)
		if result != test.expected {
			t.Errorf("Test case %d failed: expected %d, got %d", i+1, test.expected, result)
		}
	}
}
